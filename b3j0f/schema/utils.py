# -*- coding: utf-8 -*-

# --------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2016 Jonathan Labéjof <jonathan.labejof@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# --------------------------------------------------------------------

"""Schema utilities package."""

__all__ = [
    'DynamicValue', 'obj2schema', 'MetaRegisteredSchema', 'This',
    'updatecontent', 'validate', 'dump', 'RegisteredSchema'
]

from types import FunctionType, MethodType

from six import iteritems, add_metaclass

from .registry import getbydatatype, register
from .lang.factory import build
from .base import Schema, DynamicValue, RefSchema


def obj2schema(
        obj, _force=False, _besteffort=True, _registry=None, _factory=None,
        *args, **kwargs
):
    """Get the schema able to instanciate input object.

    The default value of schema will be obj.

    :param obj: object possibly generated by a schema.
    :param bool _force: if True (False by default), create the object schema
        on the fly if it does not exist.
    :param bool _besteffort: if True (default), find a schema class able to
        validate object class by inheritance.
    :param SchemaRegistry _registry: default registry to use. Global by default.
    :param SchemaFactory factory: default factory to use. Global by default.
    :param args: schema class vargs.
    :param kwargs: schema class kwargs.
    :return: Schema.
    :rtype: Schema."""

    result = None

    fobj = obj() if isinstance(obj, DynamicValue) else obj

    cls = type(fobj)

    gbdt = getbydatatype if _registry is None else _registry.getbydatatype

    schemacls = gbdt(cls, besteffort=_besteffort)

    if schemacls is None and _force:
        fbuild = build if _factory is None else _factory.build

        schemacls = fbuild(cls)

    if schemacls:
        result = schemacls(default=obj, *args, **kwargs)

    return result


class This(object):
    """Tool Used to set inner schemas with the same type with specific arguments
    .

    This one might be use at the condition instanciation methods must not
    reference the class.

    ..example::

        class Test(Schema):
            # contain an inner schema nullable 'test' of type Test.
            test = This(nullable=False)

            def __init__(self, *args, **kwargs):

                # old style call because when the schema will be automatically
                # updated, the class Test does not exist in the scope
                Schema.__init__(self, *args, **kwargs)

    :param args: schema class vargs to use.
    :param kwargs: schema class kwargs to use.

    :return: input args and kwargs.
    :rtype: tuple"""

    def __init__(self, *args, **kwargs):

        super(This, self).__init__()

        self.args = args
        self.kwargs = kwargs


def validate(schema, data, owner=None):
    """Validate input data with input schema.

    :param Schema schema: schema able to validate input data.
    :param data: data to validate.
    :param Schema owner: input schema parent schema.
    """

    schema._validate(data=data, owner=owner)


def dump(schema):
    """Get a serialized value of input schema.

    :param Schema schema: schema to serialize.
    :rtype: dict"""

    result = {}

    for name, _ in iteritems(schema.getschemas()):

        if hasattr(schema, name):
            val = getattr(schema, name)

            if isinstance(val, DynamicValue):
                val = val()

            if isinstance(val, Schema):
                val = dump(val)

            result[name] = val

    return result


def updatecontent(schemacls=None, updateparents=True, exclude=None):
    """Transform all schema class attributes to schemas.

    It can be used such as a decorator in order to ensure to update attributes
    with the decorated schema but take care to the limitation to use old style
    method call for overidden methods.

    .. example:
        @updatecontent  # update content at the end of its definition.
        class Test(Schema):
            this = This()  # instance of Test.
            def __init__(self, *args, **kwargs):
                Test.__init__(self, *args, **kwargs)  # old style method call.

    :param type schemacls: sub class of Schema.
    :param bool updateparents: if True (default), update parent content.
    :param list exclude: attribute names to exclude from updating.
    :return: schemacls"""

    if schemacls is None:
        return lambda schemacls: updatecontent(
            schemacls=schemacls, updateparents=updateparents, exclude=exclude
        )

    if updateparents:
        schemaclasses = reversed(list(schemacls.mro()))

    else:
        schemaclasses = [schemacls]

    for schemaclass in schemaclasses:

        for name, member in getattr(schemaclass, '__dict__', {}).items():

            # transform only public members
            if name[0] != '_' and (exclude is None or name not in exclude):

                toset = False  # flag for setting schemas

                fmember = member

                if isinstance(fmember, DynamicValue):
                    fmember = fmember()
                    toset = True

                if isinstance(fmember, Schema):
                    schema = fmember

                    if not schema.name:
                        schema.name = name

                else:
                    toset = True

                    if name == 'default':
                        schema = RefSchema(default=member, name=name)

                    elif isinstance(fmember, This):
                        schema = schemaclass(*fmember.args, **fmember.kwargs)

                    else:
                        schema = obj2schema(obj=member, name=name)

                if schema is not None and toset:

                    try:
                        setattr(schemaclass, name, schema)

                    except (AttributeError, TypeError):
                        break

    return schemacls


updatecontent(RefSchema)


class MetaRegisteredSchema(type):
    """Automatically register schemas."""

    def __new__(mcs, *args, **kwargs):

        result = super(MetaRegisteredSchema, mcs).__new__(mcs, *args, **kwargs)

        # update all sub schemas related to values
        if result.__update_content__:
            updatecontent(schemacls=result)

        return result

    def __call__(cls, *args, **kwargs):

        result = super(MetaRegisteredSchema, cls).__call__(*args, **kwargs)

        if result.__register__:  # register all new schema
            register(schema=result)

        return result


# use metaRegisteredschema such as the schema metaclass
@add_metaclass(MetaRegisteredSchema)
class RegisteredSchema(Schema):
    """Ease auto-registering of schemas and auto-updating content."""

    #: Register instances in the registry if True (default).
    __register__ = True

    """update automatically the content if True (default).

    If True, take care to not having called the class in overidden methods.
    In such case, take a look to the using of the class This which recommands to
    use old style method call for overriden methods.

    ..example:
        class Test(Schema):
            __udpate_content__ = True  # set update content to True
            test = This()
            def __init__(self, *args, **kwargs):
                Schema.__init__(self, *args, **kwargs)  # old style call.
        """
    __update_content__ = True
